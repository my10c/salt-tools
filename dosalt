#!/usr/bin/env bash
#
# **** DO NOT EDIT THIS FILE ****
#
# This file is managed by Salt via salt://local/sbin/dosalt
#

#
# Copyright (c) BadAssOps / Luc Suryo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#	* Redistributions of source code must retain the above copyright
#	notice, this list of conditions and the following disclaimer.
#	* Redistributions in binary form must reproduce the above copyright
#	notice, this list of conditions and the following disclaimer in the
#	documentation and/or other materials provided with the distribution.
#	* Neither the name of the <organization> nor the
#	names of its contributors may be used to endorse or promote products
#	derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSEcw
# ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#*
#* File		:	dosalt
#*
#* Description	:	wrapper script to execute command with salt, should be run on a salt master only
#*
#* Author	:	Luc Suryo <luc@badassops.com>
#*
#* Version	:	0.15
#*
#* Date		:	Jul 31, 2016
#*
#* History	:
#*		Date:			Author	Info:
#*		May 7, 2015		LS		First Release
#*		Feb 18, 2016	LS		make it more efficient and added sunc_all
#*		Feb 19, 2016	LS		change so that ommiited host == all
#*		Mar 15, 2016	LS		adding the -T flag
#*		Apr 13, 2016	LS		adding to update from repo
#*							and new flag repo to just call git update
#*		Jun 3, 2016		LS		add speratation line between command
#*		Jun 4, 2016		LS		added the --NOLOCK flags
#*		Jun 6, 2016		LS		added the ha option
#*		Jun 13, 2016	LS		added fayez and edkim to the list of users
#*		Jun 14, 2016	LS		added the --NOREPO flags
#*		Jun 21, 2016	LS		added the -P flags
#*		Jul 20, 2016	LS		added timeout to test.ping and added new option key
#*		Jul 27, 2016	LS		added the -H flag
#*		Jul 27, 2016	LIS		added the ag flag
#*		Jul 31, 2016	LIS		added the tv and tV flag
#*
# before usage adjust the values of
#	_grain_exp="ec2_tags:Name:"  <-- base onthe ec2_tags Name : the default AWS tag name-value pair
#	_grain_name=""


_program="${0##*/}"
_author='Luc Suryo'
_copyright="Copyright 2012 - $(date "+%Y") (c) BadAssOps"
_license='License BSD, http://www.freebsd.org/copyright/freebsd-license.html'
_version='0.15'
_email='luc@badassops.com'
_summary="wrapper script to execute command with salt, should be run on a salt master only"
_cancelled="OK : Process has been cancelled on your request."
_info="$_program $_version\n$_copyright\n$_license\n\nWritten by $_author <$_email>\n$_summary\n"

# Nagios defined return values
_state_ok=0
_state_warning=1
_state_critical=2
_state_unknown=3

# Whatever script needs to be run as root and exclusive lock
_need_root=1
_allowed_user="luc"
_need_lock=1

# working variables
_opid=$$
_arg2name="${HOSTNAME%%.*}"
_work_dir=/var/tmp/"$_program"
_lockfile="$_work_dir/$_program".LOCK
_echo_flag='-e'
_grain_flag=""
_host_all="*"
_grain_exp="ec2_tags:Name:"
_grain_name=""
_salt_cmd=""
_required_arg=0
_given_arg=""
_test_flag=

# Set interrupt handler
trap inthandler 1 2 3 4 5 9 10 12 15 23 24 25

function inthandler() {
	clean_up
	echo $_echo_flag "$_cancelled"
	exit $_state_ok
}

function clean_up() {
	sudo rm -f "$_lockfile" > /dev/null 2>&1
	return 0
}

function help() {
	trap 1 2 3 4 5 9 10 12 15 23 24 25
	echo $_echo_flag "$_info"
	echo $_echo_flag "Usage : $_program [-h] [-T] [--NOLOCK] <-H|-G|-P tag> <option> [service|grain|pillar] [host]"
	echo $_echo_flag " Options:"
	echo $_echo_flag "\t-T : test mode, dry-run, this applies for highstate only and must be the firts option."
	echo $_echo_flag "\tDANGER WILL ROBINSON!:"
	echo $_echo_flag "\t\t--NOLOCK: this tells $_program not to use locking!. must be the first option"
	echo $_echo_flag "\t\t--NOREPO: this tells $_program not to update the repo first!. must be the first option"
	echo $_echo_flag "\t-G usses the grain $_grain_exp while -P uses the grain $_grain_name"
	echo $_echo_flag "\t-G or -P : host selection based on grains mode, see below. Must be the firts option, or after the -T flags.\n"
	echo $_echo_flag "\t-H : single host, hostname based on salt-key, Must be the firts option, or after   the -T flags.\n"
	echo $_echo_flag "\trh == sync_grains + refresh_pillar + highstate [1]"
	echo $_echo_flag "\tah == sync_all + highstate [1]"
	echo $_echo_flag "\tkey == salt-key	           [11]"
	echo $_echo_flag "\trun_cmd (run)              [8]\n"
	echo $_echo_flag "\trepo                       [9]\n"

	echo $_echo_flag "\tsync_grains (rg)           [1]"
	echo $_echo_flag "\trefresh_pillar (rp)        [1]"
	echo $_echo_flag "\tsync_all (ra)              [1]"
	echo $_echo_flag "\thighstate (hs)             [1]\n"
	echo $_echo_flag "\tapply_apps (aa)            [10]\n"
	echo $_echo_flag "\tapply_given (ag)           [12]\n"

	echo $_echo_flag "\tcheck_for_updates (cu)     [1]"
	echo $_echo_flag "\tcheck_package (cp)         [2][1]"
	echo $_echo_flag "\tupdate_package (up)        [2][1]"
	echo $_echo_flag "\trecreate_tags (rt)         [1]\n"

	echo $_echo_flag "\tservice_status (St)        [3][8]"
	echo $_echo_flag "\tservice_stop (So)          [3][8]"
	echo $_echo_flag "\tservice_start (Sa)         [3][8]"
	echo $_echo_flag "\tservice_restart (Sr)       [3][8]\n"

	echo $_echo_flag "\tgrain_get (gg)             [4][8]"
	echo $_echo_flag "\tgrain_items (gi)           [6][1]"
	echo $_echo_flag "\tpillar_get (pg)            [5][8]"
	echo $_echo_flag "\tpillar_items (p1)          [7][1]"
	echo $_echo_flag "\ttest_ping (tp)             [1]\n"
	echo $_echo_flag "\ttest_version (tv)          [1]\n"
	echo $_echo_flag "\ttest_versions (tV)         [1]\n"
	echo $_echo_flag "\tinstall_update (sec) (run unattended-upgrade in tmux) [1]"
	echo $_echo_flag "\n"
	echo $_echo_flag "[1] takes host with or without grain (-G|-P)."
	echo $_echo_flag "    use '*' or all for all servers. If ommited then default to all. If -G|-P was given then"
	echo $_echo_flag "    the argumwnt after that wil be evaluated as the tag to use."
	echo $_echo_flag "[2] require package name. multiple package delimeted with ':'"
	echo $_echo_flag "[3] require service name."
	echo $_echo_flag "[4] require grain name."
	echo $_echo_flag "[5] require pillar name."
	echo $_echo_flag "[6] get *all* grains."
	echo $_echo_flag "[7] get *all* pillar."
	echo $_echo_flag "[8] host must given with the '-G|-P tag' argument!."
	echo $_echo_flag "[9] do a git update and exit."
	echo $_echo_flag "[10] perform a state.apply with the apps state only "
	echo $_echo_flag "[11] arguments are past to salt-key"
	clean_up
	exit $_state_warning
}

function isRoot() {
	if (($(id -u) != 0)) ; then
		 for _user in $_allowed_user
		do
			id -run | grep $_user > /dev/null 2>&1
			(( $? == 0 )) && return 0
		done
		echo $_echo_flag "\n\t*** $_program: this script must be run as the user root ***"
		echo $_echo_flag "\n\t*** also allowed user: $_allowed_user ***\n" >&2
		return 1
	fi
	return 0
}

function check_running() {
	if [[ -f "$_lockfile" ]]; then
		/bin/ps -p $(cat $_lockfile) > /dev/null 2>&1
		if (( $? == 0 )) ; then
			echo $_echo_flag "*** There is already a $_program running, execution has been terminated. ***"
			echo $_echo_flag "*** If this is an error please remove the lock file: $_lockfile ***"
			exit $_state_ok
		else
			echo $_echo_flag "*** Lock file found and deleted since there is no process with that pid ***"
			sudo rm -rf $_lockfile > /dev/null 2>&1
		fi
	fi
	if ! sudo mkdir -p "$_work_dir" > /dev/null 2>&1;then
		echo $_echo_flag "*** $_state_unknown_msg: Unable to create file working directory $_work_dir! ***"
		exit $_state_unknown
	fi
	echo "$_opid" |& sudo tee "$_lockfile" > /dev/null 2>&1
	return 0
}

function check_is_master() {
	_count=$(/bin/ps ax | grep salt-master | wc -l)
	if (( $? != 0 )) ; then
			echo $_echo_flag "*** This does'nt seem to be a salt master server, error getting the salt-master process. ***"
			exit $_state_ok
	fi
	if (( $_count < 2 )) ; then
			echo $_echo_flag "*** This does'nt seem to be a salt master server, error getting the salt-master process. ***"
			exit $_state_ok
	fi
	return 0
}

function get_given_cmd() {
	case $1
	in
		rh)						_salt_cmd="rh" ;;
		ah)						_salt_cmd="ah" ;;
		run)					_salt_cmd="run" ; _required_arg=1 ;;
		repo)					update_from_repo ; clean_up ; exit 0 ;;
		key)					_salt_cmd="key" ;;

		sync_grains|rg)			_salt_cmd="saltutil.sync_grains" ;;
		refresh_pillar|rp)		_salt_cmd="saltutil.refresh_pillar" ;;
		sync_all|ra)			_salt_cmd="ra" ;;
		highstate|hs)			_salt_cmd="state.highstate --state-output=changes $_test_flag" ;;
		apply_apps|aa)			_salt_cmd="state.apply apps --state-output=changes $_test_flag" ;;
		apply_given|ag)			_salt_cmd="ag" ; _required_arg=1 ;;

		check_for_updates|cu)	_salt_cmd="cmd.run '/usr/local/sbin/check_for_update'" ;;
		recreate_tags|rt)		_salt_cmd="cmd.run '/usr/local/sbin/re-create-tag-file'" ;;

		service_status|St)		_salt_cmd="service.status" ; _required_arg=1 ;;
		service_stop|So)		_salt_cmd="service.stop" ; _required_arg=1 ;;
		service_start|Sa)		_salt_cmd="service.start" ; _required_arg=1 ;;
		service_restart|Sr)		_salt_cmd="service.restart" ; _required_arg=1 ;;

		grain_get|gg)			_salt_cmd="grains.get" ; _required_arg=1 ;;
		grain_items|gi)			_salt_cmd="grains.items" ;;
		pillar_get|pg)			_salt_cmd="pillar.get" ; _required_arg=1 ;;
		pillar_items|pi)		_salt_cmd="pillar.items" ;;

		test_ping|tp)			_salt_cmd="--timeout 2 test.ping" ;;
		test_version|tv)		_salt_cmd="--timeout 2 test.version" ;;
		test_versions|tV)		_salt_cmd="--timeout 2 test.versions" ;;
		update_package|up)		_salt_cmd="up" ; _required_arg=1 ;;
		check_package|cp)		_salt_cmd="cp" ; _required_arg=1 ;;
		install_update|sec)		_salt_cmd="cmd.run '/usr/local/sbin/update_sec'" ;;
		*)						help ;;
	esac
	return 0
}


function check_given_arg() {
	local _error=0
	if (( $_required_arg == 0 )) ; then
		if (( $# != 0 )) ; then
			echo $_echo_flag "\t***** Option does not require any addtional argument. *****\n"
			_error=1
		fi
	fi
	if (( $_required_arg == 1 )) ; then
		if (( $# != 1 )) ; then
			if (( $# > 1 )) ; then
				echo $_echo_flag "\t***** Option require one addtional argument. Too many were given ($#) *****\n"
			else
				echo $_echo_flag "\t***** Option require one addtional argument. *****\n"
			fi
			_error=1
		fi
	fi
	(( $_error == 1 )) && help
	return $_error
}

function do_salt_ra() {
	echo $_echo_flag "\n--< saltutil.sync_grains >--"
	sudo salt $_grain_flag "$_salt_hosts" saltutil.sync_grains

	echo $_echo_flag "\n--< saltutil.refresh_pillar >--"
	sudo salt $_grain_flag "$_salt_hosts" saltutil.refresh_pillar
	
	echo $_echo_flag "\n--< saltutil.sync_all >--"
	sudo salt $_grain_flag "$_salt_hosts" saltutil.sync_all
	return $?
}

function do_salt_rh() {
	echo $_echo_flag "\n--< saltutil.sync_grains >--"
	sudo salt $_grain_flag "$_salt_hosts" saltutil.sync_grains

	echo $_echo_flag "\n--< saltutil.refresh_pillar >--"
	sudo salt $_grain_flag "$_salt_hosts" saltutil.refresh_pillar

	echo $_echo_flag "\n--< state.highstate >--"
	sudo salt $_grain_flag "$_salt_hosts" state.highstate --state-output=changes $_test_flag
	return $?
}

function do_salt_ah() {
	echo $_echo_flag "\n--< saltutil.sync_all >--"
	sudo salt $_grain_flag "$_salt_hosts" saltutil.sync_all

	echo $_echo_flag "\n--< state.highstate >--"
	sudo salt $_grain_flag "$_salt_hosts" state.highstate --state-output=changes $_test_flag
	return $?
}

function do_salt_up() {
	echo $_echo_flag "\n--< cp update_it >--"
	sudo salt-cp $_grain_flag "$_salt_hosts" /data/salt/prod/files/local/sbin/update_it /tmp/update_it

	echo $_echo_flag "\n--< run update_it >--"
	sudo salt $_grain_flag "$_salt_hosts" cmd.run "chmod 755 /tmp/update_it ; /tmp/update_it $*"
	return $?
}

function do_salt_cmd() {
	echo $_echo_flag "\n--< $_salt_cmd >--"
	sudo salt $_grain_flag "$_salt_hosts" $_salt_cmd $_given_arg
	return $?
}

function do_salt_run() {
	echo $_echo_flag "\n--< cmd.run >--"
	sudo salt $_grain_flag "$_salt_hosts" cmd.run "$*"
	return $?
}

function do_salt_ag() {
	echo $_echo_flag "\n--< state.apply $* >--"
	sudo salt $_grain_flag "$_salt_hosts" state.apply "$*" --state-output=changes $_test_flag
	return $?
}

function do_salt_key() {
	echo $_echo_flag "\n--< salt-key >--"
	sudo salt-key "$*"
	return $?
}

function do_salt_cp() {
	if [[ "$1" == "txt" ]] ; then
		_out="--out txt"
		shift
	fi
	_pkgs="$@"

	for _pkg in $_pkgs
	do
		echo "Package $_pkg"
		sudo salt '*' cmd.run $_out "/usr/local/sbin/list_pkgs $_pkg"
	done
	return $?
}

function set_host() {
	# only set if -G or -P was not given
	if [[ "$_salt_hosts" == "" ]] ; then
		if [[ "$1" == 'all' ]] ; then
			_salt_hosts="$_host_all"
		else
			_salt_hosts="*${1}*"
		fi
	fi
	return 0
}

function update_from_repo() {
	_curr=$(pwd)
	export GIT_SSH=/data/salt/prod/files/certs/github/ssh-git
	cd /data/salt/prod
	# use the salt read only key
	# downloads the latest from remote without trying to merge or rebase anything.
	sudo bash -c "( cd /data/salt/prod ;GIT_SSH=/data/salt/prod/files/certs/github/ssh-git git fetch --all > /dev/null 2>&1 )"
	# Then the git reset resets the master branch, with --hard option changes
	# all modified files to match the files in origin/master
	sudo bash -c "( cd /data/salt/prod ;GIT_SSH=/data/salt/prod/files/certs/github/ssh-git git reset --hard origin/master )"
	cd $_curr
	return $?
}

function main() {
	local _var_exit=$_state_ok
	local _do_repo=1

	check_is_master

	if (( $_need_root == 1 )) ; then
		 isRoot
		(( $? != 0 )) && echo $_echo_flag "$_info" && exit 255
	fi
	if [[ "$1" == "--NOLOCK" ]] ; then
		shift
	else
		(( $_need_lock == 1 )) && check_running
	fi
	if [[ "$1" == "--NOREPO" ]] ; then
		_do_repo=0
		shift
	fi

	if [[ "$1" == "-T" ]] ; then
		_test_flag='test=True'
		shift
	fi

	if [[ "$1" == "-H" ]] ; then
		_grain_flag=""
		_salt_hosts="${2}*"
		shift 2
	fi

	if [[ "$1" == "-G" ]] ; then
		_grain_flag="-G"
		_salt_hosts="${_grain_exp}*${2}*"
		shift 2
	fi

	if [[ "$1" == "-P" ]] ; then
		_grain_flag="-G"
		_salt_hosts="${_grain_name}*${2}*"
		shift 2
	fi


	get_given_cmd $1
	shift

	if [[ "$_salt_cmd" != "run" ]] && [[ "$_salt_cmd" != "cp" ]] ; then
		# if there is $1 then it can only be the host!
		if (( $_required_arg == 0 )) ; then
			set_host $1
			if (( $# != 0 )) ; then
				shift
			fi
		 	_given_arg="$*"
		fi

		# if there is $2 then it can only be the host!
		if (( $_required_arg == 1 )) ; then
		 	_given_arg="$1"
			set_host $2
			if (( $# > 1 )) ; then
				shift 2
			else
				shift
			fi
			_given_arg="$_given_arg $*"
		fi
		check_given_arg $_given_arg
	else
		if [[ "$_salt_cmd" == "run" ]] ; then
			# run is always in grain mode, so check if it was set correctly
			if [[ $_grain_flag != "-G" && $_grain_flag != "-P" ]] ; then
				help
			fi
		fi
		_given_arg="$*"
	fi

	if (( $_do_repo == 1 )) ; then
		# update repo and log it in case we need to see what got changed
		update_from_repo
	fi

	case $_salt_cmd
	in
		rh)		do_salt_rh ;;
		ah)		do_salt_ah ;;
		rp)		do_salt_up ;;
		ra)		do_salt_ra ;;
		key)	do_salt_key $_given_arg ;;
		cp)		do_salt_cp $_given_arg ;;
		run)	do_salt_run $_given_arg ;;
		ag)		do_salt_ag $_given_arg ;;
		*)		do_salt_cmd ;;
	esac

	trap 1 2 3 4 5 9 10 12 15 23 24 25
	clean_up
	exit $_var_exit
}
main "$@"
